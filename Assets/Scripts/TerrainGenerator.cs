using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TerrainGenerator : MonoBehaviour
{
  // Dictionary of all the chunks generated by the generator.
  public static Dictionary<Vector3Int, Chunk> chunks = new Dictionary<Vector3Int, Chunk>();

  [Header("References")]
  public GameObject chunkPrefab;
  public Transform player;
  private Grid grid;

  [Header("Generation Settings")]
  [Tooltip("Higher numbers make terrain height changes less severe over an area.")]
  public float noiseBias = 70;

  [Tooltip("(1-20) Sets the scale of the peaks and valleys.")]
  [Range(1f, 32f)]
  public float noiseScale = 12;

  // Cannot be serialized because object pooling uses this number when generating chunks.
  private int renderDistance = 10;

  private Queue<Chunk> chunkPool = new Queue<Chunk>();
  private Queue<Vector3Int> toGenerate = new Queue<Vector3Int>();
  private Vector3Int currentChunkCell = new Vector3Int(-1, -1, -1);

  void Awake()
  {
    grid = gameObject.AddComponent<Grid>();
    grid.cellGap = Vector3.zero;
    grid.cellSize = new Vector3(Chunk.width, Chunk.height, Chunk.width);
  }

  // At start, load all chunks instanteneously
  void Start()
  {
    // Initialize all of the chunks and add to pool.
    int chunkCount = (renderDistance * 2 + 1) * (renderDistance * 2 + 1);
    for (int i = 0; i < chunkCount; i++)
    {
      Chunk chunk = Instantiate(chunkPrefab).GetComponent<Chunk>();
      chunk.transform.parent = transform;
      chunk.enabled = false;
      chunkPool.Enqueue(chunk);
    }
  }

  void Update()
  {
    // Get player's chunk position.
    Vector3Int playerChunkPos = grid.WorldToCell(player.transform.position);

    // Check if player enters a new chunk.
    if (playerChunkPos == currentChunkCell) return;

    // update the currentChunkPosition
    currentChunkCell = playerChunkPos;

    // Destroy chunks outside and free up pool.
    DestroyChunksOutsideRenderDistance();
    ScheduleChunkLoading();
    StartCoroutine(AsyncBuildChunks(0.01f));
  }

  // Schedule chunk loading for chunks within the render distance.
  void ScheduleChunkLoading()
  {
    for (int i = currentChunkCell.x - 1 * renderDistance; i <= currentChunkCell.x + 1 * renderDistance; i++)
      for (int j = currentChunkCell.z - 1 * renderDistance; j <= currentChunkCell.z + 1 * renderDistance; j++)
      {
        Vector3Int cell = new Vector3Int(i, 0, j);
        if (chunks.ContainsKey(cell) || toGenerate.Contains(cell)) continue;
        toGenerate.Enqueue(cell);
      }
  }

  // Building a chunk is an expensive process, this loads chunks asynchronously to reduce load per frame.
  IEnumerator AsyncBuildChunks(float delay)
  {
    while (toGenerate.Count > 0)
    {
      if (chunkPool.Count > 0) BuildChunkVoxels(toGenerate.Dequeue());
      yield return new WaitForSeconds(delay);
    }
  }

  // Facilitates the process of assembling a chunk using Chunk.BuildMesh and TerrainGenerator.ChooseVoxelType.
  void BuildChunkVoxels(Vector3Int chunkCell)
  {
    Vector3Int chunkPosition = Vector3Int.FloorToInt(grid.GetCellCenterLocal(chunkCell) - new Vector3(Chunk.width / 2, Chunk.height / 2, Chunk.width / 2));
    Chunk chunkToBuild;
    chunkToBuild = chunkPool.Dequeue();
    chunkToBuild.gameObject.SetActive(true);
    chunkToBuild.transform.position = chunkPosition;
    for (int x = 0; x < Chunk.width; x++)
      for (int z = 0; z < Chunk.width; z++)
        for (int y = 0; y < Chunk.height; y++)
          chunkToBuild.blocks[x, y, z] = ChooseVoxelType(chunkPosition.x + x - 1, chunkPosition.y + y - 1, chunkPosition.z + z - 1);
    chunkToBuild.BuildMesh();
    chunks.Add(chunkCell, chunkToBuild);
  }

  // Destroys chunks outside the render distance by adding them to the chunk pool.
  void DestroyChunksOutsideRenderDistance()
  {
    List<Vector3Int> toDestroy = new List<Vector3Int>();

    // Pick chunks to destroy
    foreach (KeyValuePair<Vector3Int, Chunk> c in chunks)
    {
      Vector3Int chunkCell = c.Key;
      // If the chunk is out of range, add it to destroy queue.
      if (
        Mathf.Abs(currentChunkCell.x - chunkCell.x) > renderDistance ||
        Mathf.Abs(currentChunkCell.z - chunkCell.z) > renderDistance
      )
      {
        toDestroy.Add(chunkCell);
      }
    }

    // Turn off chunks and add to chunk pool to reduce delays.
    foreach (Vector3Int chunkCell in toDestroy)
    {
      chunks[chunkCell].gameObject.SetActive(false);
      chunkPool.Enqueue(chunks[chunkCell]);
      chunks.Remove(chunkCell);
    }
  }

  VoxelType ChooseVoxelType(int _x, int y, int _z)
  {
    // Prevents from spawning in the center of the world where geometry is mirrored.
    int x = _x + 30000;
    int z = _z + -50000;

    // Invert noise bias value from inspect. Higher numbers means less severe height changes.
    float b = 1 / noiseBias;

    // Generate a base heightmap using perlin noise. 
    float heightMap1 = Mathf.PerlinNoise(x * b, z * b) * (noiseScale / 2);

    // Generate a second heightmap across a wider area to get hills.
    float heightMap2 = Mathf.PerlinNoise(x * b * 5, z * b * 5) * (noiseScale / 2) * (Mathf.PerlinNoise(x * (b / 3), z * (b / 3)) + .5f);

    // Combine the two heightmaps in the middle of a chunk.
    float baseLandHeight = Chunk.height / 2f + (heightMap1 + heightMap2);

    // Use a similar technique to generate the stone heightmap.
    float stoneHeightMap1 = Mathf.PerlinNoise(x * b * 1.2f, z * b * 1.2f) * (noiseScale / 2);
    float stoneHeightMap2 = (Mathf.PerlinNoise(x * b * 3, z * b * 3) + 0.5f) * (noiseScale / 2) * 1.5f * (Mathf.PerlinNoise(x * (b / 4), z * (b / 4)) + .5f);

    // Set the base of the stone heightmap lower than the land height map. 
    float baseStoneHeight = Chunk.height / 6f + (stoneHeightMap1 + stoneHeightMap2);

    // All voxels start as air.
    VoxelType voxelType = VoxelType.Air;

    // If the voxel is below the base land height, it is one of the ground blocks.
    if (y <= baseLandHeight)
    {
      // All ground blocks are dirt by default.
      voxelType = VoxelType.Dirt;

      // If block is on top, it is grass. 
      if (y > baseLandHeight - 1) voxelType = VoxelType.Grass;

      // If block is part of stone heightmap, it is stone.
      if (y < baseStoneHeight) voxelType = VoxelType.Stone;
    }
    return voxelType;
  }
}